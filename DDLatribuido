<expression> -> <num_expression> <opt_expression>
	<expression>.node = <opt_expression>.sin
	<opt_expression>.her = <num_expression.node>

<opt_expression> -> <rel_op> <num_expression> 
	<opt_expression>.sin = new Node(<rel_op>.node, <opt_expression>.her, <num_expression>)
| &
	<opt_expression>.sin = <opt_expression>.her

<num_expression> -> <term> <opt_term>
	<num_expression>.node = <opt_term>.sin
	<opt_term>.her = <term>.node

<opt_term> -> + <term> <opt_term>(1) 
	<opt_term>(1).her = new Node('+', <opt_term>.her, <term>.node  
| - <term> <opt_term>(1) 
	<opt_term>(1).her = new Node('-', <opt_term>.her, <term>.node  
| &
	<opt_term>.sin = <opt_term>.her

<term> -> <unary_expr> <unary_vazio>
	<term>.node = <unary_vazio>.sin
	<unary_vazio>.her = <unary_expr>.node

<unary_expr> -> <factor>
	<unary_expr>.node = <factor>.sin
	<factor>.her = <pm_op?>.node
| + <factor>
	<unary_expr>.node = <factor>.sin
	<factor>.her = <pm_op?>.node
| - <factor>
	<unary_expr>.node = <factor>.sin
	<factor>.her = <pm_op?>.node


<factor> -> int-const //REFAZER
	<factor>.node = new Leaf(int-const, <factor>.her (positivo ou negativo) TabSimb(int-const)) 
| string-const 
	<factor>.node = new Leaf(string-const, TabSimb(string-const)) 
| null 
	<factor>.node = new Leaf(null, TabSimb(null)) 
| ident <lvalue> 
	<factor>.node = <lvalue>.sin
	<lvalue>.her = TabSimb(ident)
| ( <expression> )
	<factor>.node = <expression>.node

<unary_vazio> -> * <unary_expr> <unary_vazio>(1) 
	<unary_vazio>(1).her = new Node( '*' , <unary_vazio>.her, <unary_expr>.node)  
| / <unary_expr> <unary_vazio>(1) 
	<unary_vazio>(1).her = new Node( '/' , <unary_vazio>.her, <unary_expr>.node)
| % <unary_expr> <unary_vazio>(1) 
	<unary_vazio>(1).her = new Node( '%' , <unary_vazio>.her, <unary_expr>.node) 
| &
	<unary_vazio>.sin = <unary_vazio>.her

<lvalue> -> [ int-const ] <lvalue>(1) 
	<lvalue>(1).her = <lvalue>
| . ident <arg_list?> <lvalue> 
	
| &
	<lvalue>.sin = <lvalue>.her

<arg_list?> -> ( int-const ) | &
