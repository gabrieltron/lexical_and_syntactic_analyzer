<num_expression> -> <term> <opt_term>
	<num_expression>.node = <opt_term>.sin
	<opt_term>.her = <term>.node

<opt_term> -> + <term> <opt_term>(1) 
	<opt_term>(1).her = new Node('+', <opt_term>.her, <term>.node)
	<opt_term>.node = <opt_term>(1).sin
| - <term> <opt_term>(1) 
	<opt_term>(1).her = new Node('-', <opt_term>.her, <term>.node)
	<opt_term>.node = <opt_term>(1).sin
| &
	<opt_term>.sin = <opt_term>.her

<term> -> <unary_expr> <unary_vazio>
	<term>.node = <unary_vazio>.sin
	<unary_vazio>.her = <unary_expr>.node

<unary_expr> -> <factor>
	<unary_expr>.node = <factor>.node
| + <factor>
	<unary_expr>.node = new Node('+', TabSimb('0'), <factor>.node) 
| - <factor>
	<unary_expr>.node = new Node('-', TabSimb('0'), <factor>.node) 


<factor> -> int-const
	<factor>.node = new Leaf(int-const, TabSimb(int-const)) 
| string-const 
	<factor>.node = new Leaf(string-const, TabSimb(string-const)) 
| null 
	<factor>.node = new Leaf(null, TabSimb(null)) 
| ident <lvalue> 
	<factor>.node = <lvalue>.sin
	<lvalue>.her = TabSimb(ident)
| ( <num_expression> )
	<factor>.node = <expression>.node

<unary_vazio> -> * <unary_expr> <unary_vazio>(1) 
	<unary_vazio>(1).her = new Node( '*' , <unary_vazio>.her, <unary_expr>.node)
	<unary_vazio>.node = = <unary_vazio>(1).sin  
| / <unary_expr> <unary_vazio>(1) 
	<unary_vazio>(1).her = new Node( '/' , <unary_vazio>.her, <unary_expr>.node)
	<unary_vazio>.node = = <unary_vazio>(1).sin
| % <unary_expr> <unary_vazio>(1) 
	<unary_vazio>(1).her = new Node( '%' , <unary_vazio>.her, <unary_expr>.node)
	<unary_vazio>.node = = <unary_vazio>(1).sin 
| &
	<unary_vazio>.sin = <unary_vazio>.her

<lvalue> -> [ int-const ] <lvalue>(1) 
	<lvalue>(1).her = <lvalue>.her + (TypeSize(<lvalue>.her) * int-const)
	<lvalue>.node = <lvalue>(1).sin
| &
	<lvalue>.sin = <lvalue>.her
